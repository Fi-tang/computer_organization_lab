## 单周期CPU实验设计流程

### 阅读45条MIPS指令

| 指令分类                    | 需完成的指令                                                 |
| --------------------------- | ------------------------------------------------------------ |
| 运算类指令(14条)            | addiu,addu,subu,and,andi,nor,or,ori,xor,xori,slt,slti,sltu,sltiu |
| 移位指令（6条）             | sll,slv,sra,srav,srl,srlv                                    |
| 跳转类指令(10条)            | bne,beq,bgez,bgtz,blez,bltz,j,jal,jr,jalr                    |
| 访存类指令（12条)           | lb,lh,lw,lbu,lhu,lwl,lwr,sb,sh,sw,swl,swr                    |
| 数据移动及立即数指令（3条） | movn,movz,lui                                                |

#### 处理器各阶段需要的控制信号

![CPU_1](C:\Users\admin\Desktop\CPU_1.PNG)

下面的任务是，对于以上列出的所有指令，完成以下操作：

```verilog
1.31-0指令格式(截图)
2.RTF语言
3.属于哪一类型：R-Type,REGIMM,J-Type,I-Type(分支)，I-Type(运算)，I-Type(访存)
4.寄存器堆读(raddr1,raddr2)
ALU A是什么？B是什么？ALUop是什么？（这里用中文写出操作名称）
内存访问：Address, 内存访问的地址是什么？MemRead,需要读内存吗？MemWrite，需要写内存吗?,Write_Data,需要写的数据是什么？
Write_Strb,需要写哪几个字节
跳转：跳转地址，地址更新
寄存器堆写:wen 是否要写寄存器堆,waddr写地址是什么,wdata写数据是什么？
```

### 完成45条指令填充

### 运算类

#### 1.addiu（无符号立即数-字加法）

![addiu](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\addiu.PNG)

```verilog
1. 指令格式：
Instruction[31:26] = 6'b001 001;
Instruction[25:21] = rs;
Instruction[20:16] = rt;
Instruction[15:0] = immediate;
|001 001| rs(5) | rt(5) | immediate(16)|
2.RTF语言：
R[rt] <- R[rs] + immediate
3. 类型
I-Type(运算)
4，寄存器堆读
raddr1 = rs(Instruction[25:21])  raddr2(无)
5. ALU 
A: Readdata1 = R[rs]=R[Instruction[25:21]]
B: Sign_extend(immediate)  Sign_extend(Instruction[15:0])
ALUop: 无符号数加法
6.内存访问
不涉及内存访问（均设置为0）
7.跳转
不涉及跳转
8.寄存器堆写：
wen = 1 	需要写寄存器
waddr = rt = Instruction[20:16]
wdata = R[Instruction[25:21]] + Sign_extend(Instruction[15:0]) = R[rs] + imme;
```

#### 2.addu(无符号数加法)

![addu](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\addu.PNG)

```verilog
1.指令格式
| 000 000 | rs(5) | rt(5) | rd(5) | 00000 (5) | 100 001(addu)|
Instruction[31:26] = 6'b0;
Instruction[25:21] = rs;
Instruction[20:16] = rt;
Instruction[15:11] = rd;
Instruction[10:6] = 5'b0;
Instruction[5:0] = 6'b 100 001;
2.RTF语言
R[rd] <- R[rs] + R[rt]
3.类型
R-Type
4.寄存器堆读
raddr1 = R[rs] = R[Instruction[25:21]];
raddr2 = R[rt] = R[Instruction[20:16]];
5.ALU
A: R[rs]= R[Instruction[25:21]];
B: R[rt] =  R[Instruction[20:16]];
ALUop: 加法
func: 100 001
6.内存访问
无内存访问，均设为0
7.跳转
无跳转
8.寄存器堆写：
wen = 1 需要写 rd
waddr = R[rd] = R[Instruction[15:11]];
wdata = R[Instruction[25:21]] + R[Instruction[20:16]] = R[rs] + R[rt]
```

#### 3.subu(无符号 字的减法)

![subu](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\subu.PNG)

```verilog
1.指令格式
| 000 000 | rs(5) | rt(5) | rd(5) | 00 000 | 100 011|
2.RTF语言
R[rd] = R[rs] - R[rt]
3.R-Type
4.寄存器堆读
raddr1 = R[rs] = R[Instruction[25 : 21]];
raddr2 = R[rt] = R[Instruction[20 : 16]];
5.ALU
A : R[Instruction[25:21]]
B : R[Instruction[20:16]]
ALUop:减法 
func: 100 011
6.内存访问：
无内存访问
7.跳转：
无跳转
8.寄存器堆写：
wen = 1 需要写 rd
waddr = R[rd] = R[Instrucion[15:11]]
wdata = R[rs] - R[rt] = R[Instruction[25:21]] - R[Instrucion[20:16]];
```

#### 4.and(按位与)

![and](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\and.PNG)

```verilog
1.指令格式
| 000 000 | rs(5) | rt(5) | rd(5) | 00 000 | 100 100(AND)|
2.RTF语言
R[rd] = R[rs] & R[rt]
3.R-Type
4.寄存器堆读
raddr1 = R[rs] = R[Instruction[25 : 21]];
raddr2 = R[rt] = R[Instruction[20 : 16]];
5.ALU
A : R[Instruction[25:21]]
B : R[Instruction[20:16]]
ALUop:按位与
func: 100 100
6.内存访问：
无内存访问
7.跳转：
无跳转
8.寄存器堆写：
wen = 1 需要写 rd
waddr = R[rd] = R[Instrucion[15:11]]
wdata = R[rs] & R[rt] = R[Instruction[25:21]] & R[Instrucion[20:16]];
```

#### 5.andi（立即数按位与）

![andi](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\andi.PNG)

```verilog
1. 指令格式：
Instruction[31:26] = 6'b001 100;
Instruction[25:21] = rs;
Instruction[20:16] = rt;
Instruction[15:0] = immediate;
|001 100| rs(5) | rt(5) | immediate(16)|
2.RTF语言：
R[rt] <- R[rs] & zero_extend(immediate)
3. 类型
I-Type(运算)
4，寄存器堆读
raddr1 = rs(Instruction[25:21])  raddr2(无)
5. ALU 
A: Readdata1 = R[rs]=R[Instruction[25:21]]
B: zero_extend(immediate)  zero_extend(Instruction[15:0])
ALUop: R[rs] 和 0-延拓后的Immediate按位与
6.内存访问
不涉及内存访问（均设置为0）
7.跳转
不涉及跳转
8.寄存器堆写：
wen = 1 	需要写寄存器
waddr = rt = Instruction[20:16]
wdata = R[Instruction[25:21]] & zero_extend(Instruction[15:0]) = R[rs] & zero(imme) ;
```

#### 6.nor(或非门)

![nor](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\nor.PNG)

```verilog
1.指令格式
| 000 000 | rs(5) | rt(5) | rd(5) | 00 000 | 100 111(NOR)|
2.RTF语言
R[rd] = ~(R[rs] | R[rt])
3.R-Type
4.寄存器堆读
raddr1 = R[rs] = R[Instruction[25 : 21]];
raddr2 = R[rt] = R[Instruction[20 : 16]];
5.ALU
A : R[Instruction[25:21]]
B : R[Instruction[20:16]]
ALUop:按位或非
func: 100 111
6.内存访问：
无内存访问
7.跳转：
无跳转
8.寄存器堆写：
wen = 1 需要写 rd
waddr = R[rd] = R[Instrucion[15:11]]
wdata = R[rs] & R[rt] = ~(R[Instruction[25:21]] | R[Instrucion[20:16]]);
```

#### 7.or(按位或)

![or](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\or.PNG)

```verilog
1.指令格式
| 000 000 | rs(5) | rt(5) | rd(5) | 00 000 | 100 101(OR)|
2.RTF语言
R[rd] = (R[rs] | R[rt])
3.R-Type
4.寄存器堆读
raddr1 = R[rs] = R[Instruction[25 : 21]];
raddr2 = R[rt] = R[Instruction[20 : 16]];
5.ALU
A : R[Instruction[25:21]]
B : R[Instruction[20:16]]
ALUop:按位或
func: 100 101
6.内存访问：
无内存访问
7.跳转：
无跳转
8.寄存器堆写：
wen = 1 需要写 rd
waddr = R[rd] = R[Instrucion[15:11]]
wdata = R[rs] & R[rt] = (R[Instruction[25:21]] | R[Instrucion[20:16]]);
```

#### 8.ori(立即数或操作)

![ori](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\ori.PNG)

```verilog
1. 指令格式：
Instruction[31:26] = 6'b001 101;
Instruction[25:21] = rs;
Instruction[20:16] = rt;
Instruction[15:0] = immediate;
|001 100| rs(5) | rt(5) | immediate(16)|
2.RTF语言：
R[rt] <- R[rs] | zero_extend(immediate)
3. 类型
I-Type(运算)
4，寄存器堆读
raddr1 = rs(Instruction[25:21])  raddr2(无)
5. ALU 
A: Readdata1 = R[rs]=R[Instruction[25:21]]
B: zero_extend(immediate)  zero_extend(Instruction[15:0])
ALUop: R[rs] 和 0-延拓后的Immediate按位或
6.内存访问
不涉及内存访问（均设置为0）
7.跳转
不涉及跳转
8.寄存器堆写：
wen = 1 	需要写寄存器
waddr = rt = Instruction[20:16]
wdata = R[Instruction[25:21]] | zero_extend(Instruction[15:0]) = R[rs] | zero(imme);
```

#### 9.xor（按位异或）

![xor](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\xor.PNG)

```verilog
1.指令格式
| 000 000 | rs(5) | rt(5) | rd(5) | 00 000 | 100 110(OR)|
2.RTF语言
R[rd] = (R[rs] ^ R[rt])
3.R-Type
4.寄存器堆读
raddr1 = R[rs] = R[Instruction[25 : 21]];
raddr2 = R[rt] = R[Instruction[20 : 16]];
5.ALU
A : R[Instruction[25:21]]
B : R[Instruction[20:16]]
ALUop:按位异或
func: 100 110
6.内存访问：
无内存访问
7.跳转：
无跳转
8.寄存器堆写：
wen = 1 需要写 rd
waddr = R[rd] = R[Instrucion[15:11]]
wdata = R[rs] ^ R[rt] = (R[Instruction[25:21]] ^ R[Instrucion[20:16]]);
```

#### 10.xori(立即数异或)

![xori](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\xori.PNG)

```verilog
1. 指令格式：
Instruction[31:26] = 6'b001 110;
Instruction[25:21] = rs;
Instruction[20:16] = rt;
Instruction[15:0] = immediate;
|001 110| rs(5) | rt(5) | immediate(16)|
2.RTF语言：
R[rt] <- R[rs] ^ zero_extend(immediate)
3. 类型
I-Type(运算)
4，寄存器堆读
raddr1 = rs(Instruction[25:21])  raddr2(无)
5. ALU 
A: Readdata1 = R[rs]=R[Instruction[25:21]]
B: zero_extend(immediate)  zero_extend(Instruction[15:0])
ALUop: R[rs] 和 0-延拓后的Immediate按位异或
6.内存访问
不涉及内存访问（均设置为0）
7.跳转
不涉及跳转
8.寄存器堆写：
wen = 1 	需要写寄存器
waddr = rt = Instruction[20:16]
wdata = R[Instruction[25:21]]^ zero_extend(Instruction[15:0]) = R[rs] ^ zero(imme);
```

#### 11.slt(有符号数比较)

> 从slt部分的4条指令，需要用到ALU中定义的相关output

![slt](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\slt.PNG)

```verilog
1.指令格式
| 000 000 | rs(5) | rt(5) | rd(5) | 00 000 | 101 010(slt)|
2.RTF语言
R[rd] = bool((R[rs] < R[rt]))
3.R-Type
4.寄存器堆读
raddr1 = R[rs] = R[Instruction[25 : 21]];
raddr2 = R[rt] = R[Instruction[20 : 16]];
5.ALU
A : R[Instruction[25:21]]
B : R[Instruction[20:16]]
ALUop:减法
func: 101 010
6.内存访问：
无内存访问
7.跳转：
无跳转
8.寄存器堆写：
wen = 1 需要写 rd
waddr = R[rd] = R[Instrucion[15:11]]
wdata = 31'b0 || (ALUop中减法运算的最高符号位 ^ 溢出标志)
= 31'b0 || (Result_prev[31] ^ Overflow);
/*  R[rs] - R[rt] < 0
第一种情况: 符号为负（1），并且未溢出Overflow(0)
第二种情况：符号为正（0），但溢出了Overflow(1) */
```

#### 12.slti(有符号立即数比较)

![slti](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\slti.PNG)

```verilog
1. 指令格式：
Instruction[31:26] = 6'b001 010;
Instruction[25:21] = rs;
Instruction[20:16] = rt;
Instruction[15:0] = immediate;
|001 010| rs(5) | rt(5) | immediate(16)|
2.RTF语言：
R[rt] <- bool(R[rs] < sign_extend(immediate))
3. 类型
I-Type(运算)
4，寄存器堆读
raddr1 = R(Instruction[25:21])  raddr2(无)
5. ALU 
A: Readdata1 = R[rs]=R[Instruction[25:21]]
B: sign_extend(immediate)  sign_extend(Instruction[15:0])
ALUop: R[rs] 和 延拓后的Immediate相减
opcode: 001 010
6.内存访问
不涉及内存访问（均设置为0）
7.跳转
不涉及跳转
8.寄存器堆写：
wen = 1 	需要写寄存器
waddr = rt = Instruction[20:16]
wdata = R[Instruction[25:21]]- sign_extend(Instruction[15:0]) = R[rs] - sign(imme);
wdata = 31'b0 || (ALUop中减法运算的最高符号位 ^ 溢出标志)
= 31'b0 || (Result_prev[31] ^ Overflow);
/*  R[rs] - Sign(immediate) < 0
第一种情况: 符号为负（1），并且未溢出Overflow(0)
第二种情况：符号为正（0），但溢出了Overflow(1) */
```

#### 13.sltu(无符号数比较)

![sltu](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\sltu.PNG)

```verilog
1.指令格式
| 000 000 | rs(5) | rt(5) | rd(5) | 00 000 | 101 011(sltu)|
2.RTF语言
R[rd] = bool((R[rs] < R[rt]))
3.R-Type
4.寄存器堆读
raddr1 = R[rs] = R[Instruction[25 : 21]];
raddr2 = R[rt] = R[Instruction[20 : 16]];
5.ALU
A : R[Instruction[25:21]]
B : R[Instruction[20:16]]
ALUop:减法
func: 101 011
6.内存访问：
无内存访问
7.跳转：
无跳转
8.寄存器堆写：
wen = 1 需要写 rd
waddr = R[rd] = R[Instrucion[15:11]]
wdata = 31'b0 || (ALUop中减法运算的最高符号位)
= 31'b0 || (Result_prev[31]);
/*看符号位*/
```

#### 14.sltui(无符号立即数比较)

![sltiu](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\sltiu.PNG)

```verilog
1. 指令格式：
Instruction[31:26] = 6'b001 011;
Instruction[25:21] = rs;
Instruction[20:16] = rt;
Instruction[15:0] = immediate;
|001 011| rs(5) | rt(5) | immediate(16)|
2.RTF语言：
R[rt] <- bool(R[rs] < sign_extend(immediate))
3. 类型
I-Type(运算)
4，寄存器堆读
raddr1 = R(Instruction[25:21])  raddr2(无)
5. ALU 
A: Readdata1 = R[rs]=R[Instruction[25:21]]
B: sign_extend(immediate)  sign_extend(Instruction[15:0])
ALUop: R[rs] 和 无符号延拓后的Immediate相减
opcode: 001 011
6.内存访问
不涉及内存访问（均设置为0）
7.跳转
不涉及跳转
8.寄存器堆写：
wen = 1 	需要写寄存器
waddr = rt = Instruction[20:16]
wdata = R[Instruction[25:21]]- sign_extend(Instruction[15:0]) = R[rs] - sign(imme);
wdata = 31'b0 || (ALUop中减法运算的最高符号位 )
= 31'b0 || (Result_prev[31]);
```

### 移位类

#### 15.sll(shamt左移)

![sll](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\sll.PNG)

```verilog
1.指令格式
| 000 000 | 000 00 | rt(5) | rd(5) | sa(5) | 000 000(sll)|
2.RTF语言
R[rd] = R[rt] << sa
3.R-Type
4.寄存器堆读
raddr1 = 无;
raddr2 = R[rt] = R[Instruction[20 : 16]];
5.ALU
不需要ALU
6.内存访问：
无内存访问
7.跳转：
无跳转
8.寄存器堆写：
wen = 1 需要写 rd
waddr = R[rd] = R[Instruction[15:11]]
wdata = R[rt] << sa = R[Instruction[20:16]] << Instruction[10:6];
// 实际上，wdata = shifter(R[Instruction[20:16]],Instruction[10:6],左移)
9.移位器
A [31:0] = R[rt] = R[Instruction[20:16]];
B [4 : 0] = Instruction[10 : 6]; // B 表示移动多少
Shiftop: 左移，后面添 0 
输出是 : Result
需要移位器
```

#### 16.sllv（字符寄存器数据左移）

![sllv](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\sllv.PNG)

```verilog
1.指令格式
| 000 000 | rs(5) | rt(5) | rd(5) | 00 000 | 000 100(sllv)|
2.RTF语言
R[rd] = R[rt] << R[rs][5:0]
3.R-Type
4.寄存器堆读
raddr1 = R[rs][5:0] = R[Instruction[25:21]][5:0];
raddr2 = R[rt] = R[Instruction[20 : 16]];
5.ALU
不需要ALU
6.内存访问：
无内存访问
7.跳转：
无跳转
8.寄存器堆写：
wen = 1 需要写 rd
waddr = R[rd] = R[Instruction[15:11]]
wdata = R[rt] << R[rs][5:0] = R[Instruction[20:16]] << R[Instruction[25:21]][5:0];
// 实际上，wdata = shifter(R[Instruction[20:16]],Instruction[10:6],左移)
9.移位器
A [31:0] = R[rt] = R[Instruction[20:16]];
B [4 : 0] = R[Instruction[25 : 21]][5:0]; // B 表示移动多少
// A 对应Readdata2,B对应Readdata1[5:0]
Shiftop: 左移，后面添 0 
输出是 : Result
需要移位器
```

#### 17.sra(shamt算术右移)

![sra](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\sra.PNG)

```verilog
1.指令格式
| 000 000 | 000 00 | rt(5) | rd(5) | sa(5) | 000 011(sra)|
2.RTF语言
R[rd] = R[rt] >> sa
3.R-Type
4.寄存器堆读
raddr1 = 无;
raddr2 = R[rt] = R[Instruction[20 : 16]];
5.ALU
不需要ALU
6.内存访问：
无内存访问
7.跳转：
无跳转
8.寄存器堆写：
wen = 1 需要写 rd
waddr = R[rd] = R[Instruction[15:11]]
wdata = R[rt] >> sa = R[Instruction[20:16]] << Instruction[10:6];
// 实际上，wdata = shifter(R[Instruction[20:16]],Instruction[10:6],右移)
9.移位器
A [31:0] = R[rt] = R[Instruction[20:16]];
B [4 : 0] = Instruction[10 : 6]; // B 表示移动多少
Shiftop: 算术右移2'b11，前面添 R[Instruction[20:16]][20] 
输出是 : Result
需要移位器
`define DATA_WIDTH 32
module shifter(
    input [`DATA_WIDTH - 1 : 0] A,
    input [ 4 : 0] B,
    input [ 1 : 0] Shiftop,
    output [`DATA_WIDTH - 1 : 0] Result);
    
    assign Result = ( {Shiftop == 2'b00 }  & (A[31-B:0] || {B{0}} ) ) |
        ({Shiftop == 2'b11} & ({B{A[31]}}  || A[31:B]));
endmodule
```

#### 18.srav（算术右移（寄存器））

![srav](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\srav.PNG)

```verilog
1.指令格式
| 000 000 | rs(5) | rt(5) | rd(5) | 00 000 | 000 111(srav)|
2.RTF语言
R[rd] = R[rt] >> R[rs][5:0]
3.R-Type
4.寄存器堆读
raddr1 = R[rs][5:0] = R[Instruction[25:21]][5:0];
raddr2 = R[rt] = R[Instruction[20 : 16]];
5.ALU
不需要ALU
6.内存访问：
无内存访问
7.跳转：
无跳转
8.寄存器堆写：
wen = 1 需要写 rd
waddr = R[rd] = R[Instruction[15:11]]
wdata = R[rt] >> R[rs][5:0] = R[Instruction[20:16]] >> R[Instruction[25:21]][5:0];
// 实际上，wdata = shifter(R[Instruction[20:16]],Instruction[10:6],左移)
9.移位器
A [31:0] = R[rt] = R[Instruction[20:16]];
B [4 : 0] = R[Instruction[25 : 21]][5:0]; // B 表示移动多少
// A 对应Readdata2,B对应Readdata1[5:0]
Shiftop: 右移，前面添 R[rt][31] = R[Instruction[20:16]][31]; 
输出是 : Result
需要移位器
```

#### 19.srl(逻辑右移)

![srl](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\srl.PNG)

```verilog
1.指令格式
| 000 000 | 000 00 | rt(5) | rd(5) | sa(5) | 000 010(srl)|
2.RTF语言
R[rd] = R[rt] >> sa(logical)
3.R-Type
4.寄存器堆读
raddr1 = 无;
raddr2 = R[rt] = R[Instruction[20 : 16]];
5.ALU
不需要ALU
6.内存访问：
无内存访问
7.跳转：
无跳转
8.寄存器堆写：
wen = 1 需要写 rd
waddr = R[rd] = R[Instruction[15:11]]
wdata = R[rt] >> sa = R[Instruction[20:16]] >> Instruction[10:6];
// 实际上，wdata = shifter(R[Instruction[20:16]],Instruction[10:6],逻辑右移)
9.移位器
A [31:0] = R[rt] = R[Instruction[20:16]];
B [4 : 0] = Instruction[10 : 6]; // B 表示移动多少
Shiftop: 逻右移2'b10，前面添 Instruction[10:6]个 0 
输出是 : Result
需要移位器
`define DATA_WIDTH 32
module shifter(
    input [`DATA_WIDTH - 1 : 0] A,
    input [ 4 : 0] B,
    input [ 1 : 0] Shiftop,
    output [`DATA_WIDTH - 1 : 0] Result);
    
    assign Result = ( {Shiftop == 2'b00 }  & (A[31-B:0] || {B{0}} ) ) |
        ({Shiftop == 2'b11} & ({B{A[31]}}  || A[31:B])) |
        ({Shiftop == 2'b10} & ({B{0}} || A[31:B] ));
endmodule
```

#### 20.srlv(寄存器逻辑右移)

![srlv](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\srlv.PNG)

```verilog
1.指令格式
| 000 000 | rs(5) | rt(5) | rd(5) | 00 000 | 000 110(srlv)|
2.RTF语言
R[rd] = R[rt] >> R[rs][5:0]
3.R-Type
4.寄存器堆读
raddr1 = R[rs][5:0] = R[Instruction[25:21]][5:0];
raddr2 = R[rt] = R[Instruction[20 : 16]];
5.ALU
不需要ALU
6.内存访问：
无内存访问
7.跳转：
无跳转
8.寄存器堆写：
wen = 1 需要写 rd
waddr = R[rd] = R[Instruction[15:11]]
wdata = R[rt] >> R[rs][5:0] = R[Instruction[20:16]] >> R[Instruction[25:21]][5:0];
// 实际上，wdata = shifter(R[Instruction[20:16]],Instruction[10:6],左移)
9.移位器
A [31:0] = R[rt] = R[Instruction[20:16]];
B [4 : 0] = R[Instruction[25 : 21]][5:0]; // B 表示移动多少
// A 对应Readdata2,B对应Readdata1[5:0]
Shiftop: 逻辑右移，前面添 R[Instruction[25 : 21]] 个 {0}
输出是 : Result
需要移位器
```

### 跳转类

#### 21.bne（branch on not equal)

![bne](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\bne.PNG)

```verilog
1. 指令格式：
Instruction[31:26] = 6'b000 101;
Instruction[25:21] = rs;
Instruction[20:16] = rt;
Instruction[15:0] = offset;
|000 101| rs(5) | rt(5) | offset(16)|
2.RTF语言：
if R[rs] != R[rt] then PC <- PC + sign_extend(offset || {2{0}})
3. 类型
I-Type(分支)
4，寄存器堆读
raddr1 = R(Instruction[25:21]) = R[rs]
raddr2 = R(Instruction[20:16]) = R[rt]
5. ALU 
A: Readdata1 = R[rs]=R[Instruction[25:21]]
B: Readdata2 = R[rt] = R[Instruction[20:16]]
ALUop: R[rs] - R[rt]
opcode: 000 101
6.内存访问
不涉及内存访问（均设置为0）
7.跳转
跳转地址：PC + sign_extend(offset || {2{0}})
= PC + sign_extend(Instruction[15:0] || {2{0}})
// ~Zero & branch == 1
地址更新条件：Zero标志位为 0,两寄存器内容不相等
8.寄存器堆写：
不需要写寄存器
```

#### 22.beq（branch on equal)

![beq](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\beq.PNG)

```verilog
1. 指令格式：
Instruction[31:26] = 6'b000 100;
Instruction[25:21] = rs;
Instruction[20:16] = rt;
Instruction[15:0] = offset;
|000 100| rs(5) | rt(5) | offset(16)|
2.RTF语言：
if R[rs] == R[rt] then PC <- PC + sign_extend(offset || {2{0}})
3. 类型
I-Type(分支)
4，寄存器堆读
raddr1 = R(Instruction[25:21]) = R[rs]
raddr2 = R(Instruction[20:16]) = R[rt]
5. ALU 
A: Readdata1 = R[rs]=R[Instruction[25:21]]
B: Readdata2 = R[rt] = R[Instruction[20:16]]
ALUop: R[rs] - R[rt]
opcode: 000 100
6.内存访问
不涉及内存访问（均设置为0）
7.跳转
跳转地址：PC + sign_extend(offset || {2{0}})
= PC + sign_extend(Instruction[15:0] || {2{0}})
// Zero & branch == 1
地址更新条件：Zero标志位为 1,两寄存器内容相等
8.寄存器堆写：
不需要写寄存器
```

#### 23.bgez （branch on rs >= 0)

![bgez](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\bgez.PNG)

```verilog
1. 指令格式：
Instruction[31:26] = 6'b000 001(REGIMM);
Instruction[25:21] = rs;
Instruction[20:16] = 000 01(bgez);
Instruction[15:0] = offset;
|000 001| rs(5) | 000 01(bgez) | offset(16)|
2.RTF语言：
if R[rs] >= 0 then PC <- PC + sign_extend(offset || {2{0}})
3. 类型
REGIMM
4，寄存器堆读
raddr1 = R(Instruction[25:21]) = R[rs]
// 和 0 号寄存器中的内容比较
raddr2 = R(5{0}) = R[0]
5. ALU 
A: Readdata1 = R[rs]=R[Instruction[25:21]]
B: Readdata2 = R[0] = 5'b0
ALUop: R[rs] - R[0]
opcode: 000 001
6.内存访问
不涉及内存访问（均设置为0）
7.跳转
跳转地址：PC + sign_extend(offset || {2{0}})
= PC + sign_extend(Instruction[15:0] || {2{0}})

地址更新条件：R[rs] 中的内容 >= 0
一种可行的方案是借助 ALU,判断最终得到 - 0 的最高符号位 Result_prev[31]是否为 0
if (Result_prev[31] == 0) then branch
    
8.寄存器堆写：
不需要写寄存器
```

#### 24.bgtz(branch on rs > 0）

![bgtz](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\bgtz.PNG)

```verilog
1. 指令格式：
Instruction[31:26] = 6'b000 111(BGTZ);
Instruction[25:21] = rs;
Instruction[20:16] = 000 00;
Instruction[15:0] = offset;
|000 111(bgtz)| rs(5) | 000 00 | offset(16)|
2.RTF语言：
if R[rs] > 0 then PC <- PC + sign_extend(offset || {2{0}})
3. 类型
    REGIMM / I-type(分支)
4，寄存器堆读
	raddr1 = R(Instruction[25:21]) = R[rs]
	// 和 0 号寄存器中的内容比较
    raddr2 = R(Instruction[20:16]) = R[0]
5. ALU 
	A: Readdata1 = R[rs]=R[Instruction[25:21]]
    B: Readdata2 = R[Instruction[20:16]] = 5'b0
	ALUop: R[rs] - R[0]
	opcode: 000 111
6.内存访问
不涉及内存访问（均设置为0）
7.跳转
跳转地址：PC + sign_extend(offset || {2{0}})
= PC + sign_extend(Instruction[15:0] || {2{0}})

地址更新条件：R[rs] 中的内容 > 0
    一种可行的方案是借助 ALU,判断最终得到 - 0 的最高符号位 Result_prev[31]是否为 0,
    并且需要通过溢出进行判断：
    1.首先Zero不能等于1，即两者不能相等 2.其次判断符号
    // 符号位结果为 0，表明为正数
    if ( ~ Zero && ~(Result[31])) 
        then branch   
8.寄存器堆写：
不需要写寄存器
```

#### 25.blez（branch on <= 0)

![blez](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\blez.PNG)

```verilog
1. 指令格式：
Instruction[31:26] = 6'b000 110(BLEZ);
Instruction[25:21] = rs;
Instruction[20:16] = 000 00;
Instruction[15:0] = offset;
|000 110(blez)| rs(5) | 000 00 | offset(16)|
2.RTF语言：
if R[rs] <= 0 then PC <- PC + sign_extend(offset || {2{0}})
3. 类型
    REGIMM/I-type(分支)
4，寄存器堆读
raddr1 = R(Instruction[25:21]) = R[rs]
// 和 0 号寄存器中的内容比较
    raddr2 = R(Instruction[20:16]) = R[0]
5. ALU 
A: Readdata1 = R[rs]=R[Instruction[25:21]]
    B: Readdata2 = R(Instruction[20:16]) = R[0]
ALUop: R[rs] - R[0]
opcode: 000 110
6.内存访问
不涉及内存访问（均设置为0）
7.跳转
跳转地址：PC + sign_extend(offset || {2{0}})
= PC + sign_extend(Instruction[15:0] || {2{0}})

    地址更新条件：R[rs] 中的内容 <= 0
一种可行的方案是借助 ALU,判断最终得到 - 0 的最高符号位 Result_prev[31]是否为 0
    if (Result_prev[31] == 1 || Zero) then branch
    
8.寄存器堆写：
不需要写寄存器
```

#### 26.bltz(branch on < 0)

![bltz](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\bltz.PNG)

```verilog
1. 指令格式：
Instruction[31:26] = 6'b000 001(REGIMM);
Instruction[25:21] = rs;
Instruction[20:16] = 000 00(BLTZ);
Instruction[15:0] = offset;
|000 001| rs(5) | 000 00 | offset(16)|
2.RTF语言：
if R[rs] < 0 then PC <- PC + sign_extend(offset || {2{0}})
3. 类型
    REGIMM / I-type(分支)
4，寄存器堆读
	raddr1 = R(Instruction[25:21]) = R[rs]
	// 和 0 号寄存器中的内容比较
    raddr2 = R(Instruction[20:16]) = R[0]
5. ALU 
	A: Readdata1 = R[rs]=R[Instruction[25:21]]
    B: Readdata2 = R[Instruction[20:16]] = 5'b0
	ALUop: R[rs] - R[0]
	opcode: 000 001
6.内存访问
不涉及内存访问（均设置为0）
7.跳转
跳转地址：PC + sign_extend(offset || {2{0}})
= PC + sign_extend(Instruction[15:0] || {2{0}})

    地址更新条件：R[rs] 中的内容 < 0
    一种可行的方案是借助 ALU,判断最终得到 - 0 的最高符号位 Result_prev[31]是否为 1
    1.首先Zero不能等于1，即两者不能相等 2.其次判断符号
    // 符号位结果为 1，表明为负数
    if ( ~ Zero && (Result[31])) 
        then branch   
8.寄存器堆写：
不需要写寄存器
```

#### 27.J（跳转）

![j](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\j.PNG)

```verilog
1. 指令格式：
|000 010(J)|  instr_index(26) |
2.RTF语言：
PC <- PC[31:28] || instr_index || {2{0}}
3. 类型
    J-Type
4，寄存器堆读
	不需要读寄存器堆
5. ALU 
	不需要这里的ALU
6.内存访问
不涉及内存访问（均设置为0）
7.跳转
跳转地址：PC[31:28] || Instruction[25:0] || {2{0}})

    地址更新条件：无条件
	需要地址加法器
	1.PC已经变成 PC + 4
	2. PC[31:28] 取左移两位后的 instr_index 连接
	
8.寄存器堆写：
不需要写寄存器
```

#### 28.Jal（跳转并记录过程调用返回）

![jal](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\jal.PNG)

```verilog
1. 指令格式：
|000 011(J)|  instr_index(26) |
2.RTF语言：
R[31] <- PC + 8
PC <- PC[31:28] || instr_index || {2{0}}
3. 类型
    J-Type
4，寄存器堆读
	不需要读寄存器堆
5. ALU 
	不需要这里的ALU
6.内存访问
不涉及内存访问（均设置为0）
7.跳转
跳转地址：PC[31:28] || Instruction[25:0] || {2{0}})

    地址更新条件：无条件
	需要地址加法器
	1.PC已经变成 PC + 4
	2. PC[31:28] 取左移两位后的 instr_index 连接
	
8.寄存器堆写：
	wen = 1
	waddr = 31
	wdata = PC + 8
```

#### 29.jr(跳转到寄存器内容处的PC)

![jr](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\jr.PNG)

```verilog
1. 指令格式：
| 000 000 | rs(5) | 0 (10) | hint(5) | 001 000 (JR)|
2.RTF语言：
PC <- R[rs]
3. 类型
    R-Type
4，寄存器堆读
raddr1 = R[Instruction[25:21]];
raddr2 = 无;
5. ALU 
	不需要这里的ALU
6.内存访问
不涉及内存访问（均设置为0）
7.跳转
跳转地址: R[rs]
地址更新条件： 无条件
8.寄存器堆写：
不需要写寄存器堆
```

#### 30.jalr（跳转并保存返回地址）

![jalr](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\jalr.PNG)

```verilog
1. 指令格式：
| 000 000 | rs(5) | 0 (5) | rd(5) | hint(5) | 001 001 (jalr) |
2.RTF语言：
PC <- R[rs] 
R[rd] <- PC + 8
3. 类型
    R-Type
4，寄存器堆读
raddr1 = R[Instruction[25:21]];
raddr2 = 无;
5. ALU 
	需要计算 PC + 8
6.内存访问
不涉及内存访问（均设置为0）
7.跳转
跳转地址: R[rs]
地址更新条件： 无条件
8.寄存器堆写：
wen = 1
waddr = R[rd] = R[Instruction[15:11]]
wdata = PC + 8
```

### 访存类

#### 31.lb（加载 8-bit 字节）

![lb](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\lb.PNG)

```verilog
1. 指令格式：
| 100 000 | base(5) | rt(5) | offset(16) |
2.RTF语言：
R[rt] <- mem[base + offset]
3. 类型
I-Type(访存)
4，寄存器堆读
raddr1 = R[Instruction[25:21]] = R[base] // 可以认为是 R[rs]
raddr2 = 无
5. ALU
A: R[Instruction[25:21]] = R[base]
B: sign_extend(Instruction[15:0])
ALUop : 有符号数加法
6.内存访问
Address : ALU Result = R[base] + Sign_extend(Instruction[15:0])
MemRead : 1
Read需要在内部赋值 Read_strb 这里只能有{1000，0100，0010，0001}四种之一
MemWrite : 0
Write_Data : 不需要写
Write_Strb : 0000
7.跳转
不需要跳转
8.寄存器堆写：
wen = 1
waddr = R[rt] = R[Instruction[20:16]]
wdata =sign_extend(mem[R[Instruction[25:21]] + sign_extend(Instruction[15:0])])
即 sign_extend(memword[7 + 8*byte,8*byte])
// 需要对取得的 8 -bit 进行符号位扩展后放入R[rt]
```

#### 32.lh(加载半字 16-bit)

![lh](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\lh.PNG)

```verilog
1. 指令格式：
| 100 001 | base(5) | rt(5) | offset(16) |
2.RTF语言：
R[rt] <- mem[base + offset]
3. 类型
I-Type(访存)
4，寄存器堆读
raddr1 = R[Instruction[25:21]] = R[base] // 可以认为是 R[rs]
raddr2 = 无
5. ALU
A: R[Instruction[25:21]] = R[base]
B: sign_extend(Instruction[15:0])
ALUop : 有符号数加法
6.内存访问
Address : ALU Result = R[base] + Sign_extend(Instruction[15:0])
MemRead : 1
Read需要在内部赋值 Read_strb 这里只能有{1100，0011}两种之一
MemWrite : 0
Write_Data : 不需要写
Write_Strb : 0000
7.跳转
不需要跳转
8.寄存器堆写：
wen = 1
waddr = R[rt] = R[Instruction[20:16]]
wdata =sign_extend(mem[R[Instruction[25:21]] + sign_extend(Instruction[15:0])])
即 sign_extend(memword[15 + 8*byte,8*byte])
// 需要对取得的 16 -bit 进行符号位扩展后放入R[rt]
```

#### 33.lw(加载字 32-bit)

![lw](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\lw.PNG)

```verilog
1. 指令格式：
| 100 011 | base(5) | rt(5) | offset(16) |
2.RTF语言：
R[rt] <- mem[base + offset]
3. 类型
I-Type(访存)
4，寄存器堆读
raddr1 = R[Instruction[25:21]] = R[base] // 可以认为是 R[rs]
raddr2 = 无
5. ALU
A: R[Instruction[25:21]] = R[base]
B: sign_extend(Instruction[15:0])
ALUop : 有符号数加法
6.内存访问
Address : ALU Result = R[base] + Sign_extend(Instruction[15:0])
MemRead : 1
Read需要在内部赋值 Read_strb 这里为 1111
MemWrite : 0
Write_Data : 不需要写
Write_Strb : 0000
7.跳转
不需要跳转
8.寄存器堆写：
wen = 1
waddr = R[rt] = R[Instruction[20:16]]
wdata =mem[R[Instruction[25:21]] + sign_extend(Instruction[15:0])]
// 需要对取得的 32 -bit 放入R[rt]
```

#### 34.lbu（加载无符号字节）

![lbu](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\lbu.PNG)

```verilog
1. 指令格式：
| 100 100 | base(5) | rt(5) | offset(16) |
2.RTF语言：
R[rt] <- mem[base + offset]
3. 类型
I-Type(访存)
4，寄存器堆读
raddr1 = R[Instruction[25:21]] = R[base] // 可以认为是 R[rs]
raddr2 = 无
5. ALU
A: R[Instruction[25:21]] = R[base]
B: sign_extend(Instruction[15:0])
ALUop : 有符号数加法
6.内存访问
Address : ALU Result = R[base] + sign_extend(Instruction[15:0])
MemRead : 1
Read需要在内部赋值 Read_strb 这里只能有{1000，0100，0010，0001}四种之一
MemWrite : 0
Write_Data : 不需要写
Write_Strb : 0000
7.跳转
不需要跳转
8.寄存器堆写：
wen = 1
waddr = R[rt] = R[Instruction[20:16]]
wdata =zero_extend(mem[R[Instruction[25:21]] + sign_extend(Instruction[15:0])])
即 zero_extend(memword[7 + 8*byte,8*byte])
// 需要对取得的 8 -bit 进行零延拓后放入R[rt]
```

#### 35.lhu（加载无符号半字）

![lhu](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\lhu.PNG)

```verilog
1. 指令格式：
| 100 101 | base(5) | rt(5) | offset(16) |
2.RTF语言：
R[rt] <- mem[base + offset]
3. 类型
I-Type(访存)
4，寄存器堆读
raddr1 = R[Instruction[25:21]] = R[base] // 可以认为是 R[rs]
raddr2 = 无
5. ALU
A: R[Instruction[25:21]] = R[base]
B: sign_extend(Instruction[15:0])
ALUop : 有符号数加法
6.内存访问
Address : ALU Result = R[base] + sign_extend(Instruction[15:0])
MemRead : 1
Read需要在内部赋值 Read_strb 这里只能有{1100，0011}两种之一
MemWrite : 0
Write_Data : 不需要写
Write_Strb : 0000
7.跳转
不需要跳转
8.寄存器堆写：
wen = 1
waddr = R[rt] = R[Instruction[20:16]]
wdata =zero_extend(mem[R[Instruction[25:21]] + sign_extend(Instruction[15:0])])
即 zero_extend(memword[15 + 8*byte,8*byte])
// 需要对取得的 16 -bit 进行零延拓后放入R[rt]
```

#### 36.lwl(加载未对齐字段，左边部分)

![lwl](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\lwl.PNG)

```verilog
1. 指令格式：
| 100 010(lwl) | base(5) | rt(5) | offset(16) |
2.RTF语言：
R[rt] <-  mem[base + offset][31:16] || R[rt][15:0]
3. 类型
I-Type(访存)
4，寄存器堆读
raddr1 = R[Instruction[25:21]] = R[base] // 可以认为是 R[rs]
raddr2 = 无
5. ALU
A: R[Instruction[25:21]] = R[base]
B: sign_extend(Instruction[15:0])
ALUop : 有符号数加法
6.内存访问
Address : ALU Result = R[base] + sign_extend(Instruction[15:0])
MemRead : 1
Read需要在内部赋值 Read_strb = 4'b0011;
MemWrite : 0
Write_Data : 不需要写
Write_Strb : 0000
7.跳转
不需要跳转
8.寄存器堆写：
wen = 1
waddr = R[rt] = R[Instruction[20:16]]
wdata = (R[Instruction[25:21]] + sign_extend(Instruction[15:0]))[31:16]
设定寄存器堆写有效或者写无效
寄存器堆的写 RF_write_strb = 4'b1100;
```

#### 37.lwr(加载未对齐右半字)

![lwr](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\lwr.PNG)

```verilog
1. 指令格式：
| 100 110(lwr) | base(5) | rt(5) | offset(16) |
2.RTF语言：
R[rt] <- R[rt][31:16] || mem[base + offset][15:0]
3. 类型
I-Type(访存)
4，寄存器堆读
raddr1 = R[Instruction[25:21]] = R[base] // 可以认为是 R[rs]
raddr2 = 无
5. ALU
A: R[Instruction[25:21]] = R[base]
B: sign_extend(Instruction[15:0])
ALUop : 有符号数加法
6.内存访问
Address : ALU Result = R[base] + sign_extend(Instruction[15:0])
MemRead : 1
Read需要在内部赋值 Read_strb = 4'b1100;
MemWrite : 0
Write_Data : 不需要写
Write_Strb : 0000
7.跳转
不需要跳转
8.寄存器堆写：
wen = 1
waddr = R[rt] = R[Instruction[20:16]]
wdata = (R[Instruction[25:21]] + sign_extend(Instruction[15:0]))[15:0]
设定寄存器堆写有效或者写无效
寄存器堆的写 RF_write_strb = 4'b0011;
```

#### 38.sb(存储字节)

![sb](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\sb.PNG)

```verilog
1. 指令格式：
| 101 000 | base(5) | rt(5) | offset(16) |
2.RTF语言：
mem[base + offset] <- R[rt] 
3. 类型
I-Type(访存)
4，寄存器堆读
raddr1 = R[Instruction[25:21]] = R[base] // 可以认为是 R[rs]
raddr2 = 无
5. ALU
A: R[Instruction[25:21]] = R[base]
B: sign_extend(Instruction[15:0])
ALUop : 有符号数加法
6.内存访问
Address : ALU Result = R[base] + sign_extend(Instruction[15:0])
MemRead : 0
MemWrite : 1
需要写内存
Write_Data : R[rt] = R[Instruction[20:16]]
Write_Strb : 1000(大端序) 0001（小端序）
7.跳转
不需要跳转
8.寄存器堆写：
不需要写寄存器堆
```

#### 39.sh(存储半字)

![sh](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\sh.PNG)

```verilog
1. 指令格式：
| 101 001 | base(5) | rt(5) | offset(16) |
2.RTF语言：
mem[base + offset] <- R[rt] 
3. 类型
I-Type(访存)
4，寄存器堆读
raddr1 = R[Instruction[25:21]] = R[base] // 可以认为是 R[rs]
raddr2 = 无
5. ALU
A: R[Instruction[25:21]] = R[base]
B: sign_extend(Instruction[15:0])
ALUop : 有符号数加法
6.内存访问
Address : ALU Result = R[base] + sign_extend(Instruction[15:0])
MemRead : 0
MemWrite : 1
需要写内存
Write_Data : R[rt] = R[Instruction[20:16]]
Write_Strb : 1100(大端序) 0011（小端序）
7.跳转
不需要跳转
8.寄存器堆写：
不需要写寄存器堆
```

#### 40.sw(存储字)

![sw](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\sw.PNG)

```verilog
1. 指令格式：
| 101 011 | base(5) | rt(5) | offset(16) |
2.RTF语言：
mem[base + offset] <- R[rt] 
3. 类型
I-Type(访存)
4，寄存器堆读
raddr1 = R[Instruction[25:21]] = R[base] // 可以认为是 R[rs]
raddr2 = 无
5. ALU
A: R[Instruction[25:21]] = R[base]
B: sign_extend(Instruction[15:0])
ALUop : 有符号数加法
6.内存访问
Address : ALU Result = R[base] + sign_extend(Instruction[15:0])
MemRead : 0
MemWrite : 1
需要写内存
Write_Data : R[rt] = R[Instruction[20:16]]
Write_Strb : 1111
7.跳转
不需要跳转
8.寄存器堆写：
不需要写寄存器堆
```

#### 41.swl(存储左边半字)

![swl](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\swl.PNG)

```verilog
1. 指令格式：
| 101 010(lwl) | base(5) | rt(5) | offset(16) |
2.RTF语言：
mem[base + offset] <- R[rt]
3. 类型
I-Type(访存)
4，寄存器堆读
raddr1 = R[Instruction[25:21]] = R[base] // 可以认为是 R[rs]
raddr2 = 无
5. ALU
A: R[Instruction[25:21]] = R[base]
B: sign_extend(Instruction[15:0])
ALUop : 有符号数加法
6.内存访问
Address : ALU Result = R[base] + sign_extend(Instruction[15:0])
MemRead : 0
MemWrite : 1
Write_Data : R[rt][31:16]
Write_Strb : 0011
7.跳转
不需要跳转
8.寄存器堆写：
不需要写寄存器堆
```

#### 42.swr（存储右边半字）

![swr](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\swr.PNG)

```verilog
1. 指令格式：
| 101 110(swr) | base(5) | rt(5) | offset(16) |
2.RTF语言：
mem[base + offset] <- R[rt]
3. 类型
I-Type(访存)
4，寄存器堆读
raddr1 = R[Instruction[25:21]] = R[base] // 可以认为是 R[rs]
raddr2 = 无
5. ALU
A: R[Instruction[25:21]] = R[base]
B: sign_extend(Instruction[15:0])
ALUop : 有符号数加法
6.内存访问
Address : ALU Result = R[base] + sign_extend(Instruction[15:0])
MemRead : 0
MemWrite : 1
Write_Data : R[rt][15:00]
Write_Strb : 1100
7.跳转
不需要跳转
8.寄存器堆写：
不需要写寄存器堆
```

### 立即数

#### 43.movn(非零时移动)

![movn](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\movn.PNG)

```verilog
1. 指令格式：
| 000 000 | rs(5) | rt(5) | rd(5) | 00 000 | 001 011(movn)|
2.RTF语言：
if R[rt] != 0 then R[rd] <- R[rs]
3. 类型
R-Type
4，寄存器堆读
    raddr1 = R[Instruction[25:21]] = R[rs]
    raddr2 = R[Instruction[20:16]] = R[rt]
5. ALU
    A: R[Instruction[20:16]] = R[rt]
    B: 0 
ALUop : 有符号数减法
6.内存访问
不需要内存访问
7.跳转
不需要跳转
8.寄存器堆写：
    if(Zero == 0)  then wen = 1
    waddr = rd = Instruction[15:11]
    wdata = R[rs] = R[Instruction[25:21]]
```

#### 44.movz（零时移动）

![movz](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\movz.PNG)

```verilog
1. 指令格式：
| 000 000 | rs(5) | rt(5) | rd(5) | 00 000 | 001 010(movz)|
2.RTF语言：
if R[rt] == 0 then R[rd] <- R[rs]
3. 类型
R-Type
4，寄存器堆读
    raddr1 = R[Instruction[25:21]] = R[rs]
    raddr2 = R[Instruction[20:16]] = R[rt]
5. ALU
    A: R[Instruction[20:16]] = R[rt]
    B: 0 
ALUop : 有符号数减法
6.内存访问
不需要内存访问
7.跳转
不需要跳转
8.寄存器堆写：
    if(Zero == 1)  then wen = 1
    waddr = rd = Instruction[15:11]
    wdata = R[rs] = R[Instruction[25:21]]
```

#### 45.lui(存储无符号半字)

![lui](C:\Users\admin\Desktop\组成原理\实验二_单周期CPU\45条指令截图\lui.PNG)

```verilog
1. 指令格式：
| 001 111(lhu) | 000 00 | rt(5) | immediate(16) |
2.RTF语言：
R[rt] <- immediate || {16{0}}
3. 类型
I-Type(运算)
4，寄存器堆读
不需要读
5. ALU
不需要ALU
6.内存访问
不需要内存访问
7.跳转
不需要跳转
8.寄存器堆写：
wen = 1
waddr = rt = Instruction[20:16]
wdata = Instruction[15 : 0] || {16{0}}
```

