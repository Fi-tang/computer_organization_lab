## HDLBits时序电路习题

### Fsm1

下面列出一个Moore类型的状态机，具有两个状态，一个输入和一个输出。实现下列状态机，注意到复位状态是 B

![Fsm1](C:\Users\admin\Desktop\组成原理\实验二_多周期CPU\Fsm1.PNG)

对上图作出一些解释：

````verilog
复位信号有效时，达到状态 B
在状态 B 下，输出为 out = 1
如果在状态 B 下，输入 1 ,则回到状态 B
如果在状态 B 下，输入 0,则达到状态 A
在状态 A 下，输出为 out = 0;
如果在状态 A 下，输入 0，则回到状态 B
如果在状态 A 下，输入 1,则回到状态 A
````

初步的代码如下

```verilog
module top_module(
	input clk,
	input areset,
	input in,
    output out );
    
    localparam A = 1'b0,
    		  B = 1'b1;
    reg current_state;
    reg next_state;
    always @(posedge clk,posedge areset)begin
        if(areset)
            current_state <= B;
        else
            current_state <= next_state;
    end
    
    always @(posedge clk ,localparam A)
        if(in == 1)
            next_state <= A;
    	else
            next_state <= B;
    end
    always @(posedge clk ,localparam B)
        if(in == 1)
            next_state <= B;
    	else
            next_state <= A;
    end
    always@(posedge clk)
        if(current_state == A)
            out <= 0;
   		else
            out <= 1;
    end
endmodule
    
```

首先是跑不通的，看一下正确写法。

```verilog
module top_module(
	input clk,
	input areset, // 异步复位到状态 B
	input in,
    output out); 
    
    parameter A = 0, B = 1;
    reg state, next_state;
    
    always @(*) begin 	// 这是一个组合逻辑块
        // 状态转换逻辑
        case(state)
            B : next_state = in? B : A;
            A : next_state = in? A : B;
        endcase
    end
    
    always @(posedge clk,posedge areset) begin // 这是一个时序的 always 块
        // 状态触发器是异步复位的
        if(areset) state <= B;
        else state <= next_state;
    end
    // 输出逻辑，根据当前状态实现输出
    assign out = state? 1 : 0;
endmodule
```

官方答案：

```verilog
module top_module (
	input clk,
	input in,
	input areset,
	output out
);

	// Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	parameter A=0, B=1;
	reg state;		// Ensure state and next are big enough to hold the state encoding.
	reg next;
    
    
    // A finite state machine is usually coded in three parts:
    //   State transition logic
    //   State flip-flops
    //   Output logic
    // It is sometimes possible to combine one or more of these blobs of code
    // together, but be careful: Some blobs are combinational circuits, while some
    // are clocked (DFFs).
    
    
    // Combinational always block for state transition logic. Given the current state and inputs,
    // what should be next state be?
    // Combinational always block: Use blocking assignments.
    always@(*) begin
		case (state)
			A: next = in ? A : B;
			B: next = in ? B : A;
		endcase
    end
    
    
    
    // Edge-triggered always block (DFFs) for state flip-flops. Asynchronous reset.
    always @(posedge clk, posedge areset) begin
		if (areset) state <= B;		// Reset to state B
        else state <= next;			// Otherwise, cause the state to transition
	end
		
		
		
	// Combinational output logic. In this problem, an assign statement is the simplest.
	// In more complex circuits, a combinational always block may be more suitable.
	assign out = (state==B);

	
endmodule
```

